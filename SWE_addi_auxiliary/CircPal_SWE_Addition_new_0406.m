
% =========================================================================
% INTRO
%   - Calculate the sound pressure generated by a circular radiator using
%       the spherical wave expansion
%   - Modified based on CircSrcZernike_Exp_220420A.m
% -------------------------------------------------------------------------
% INPUT
%   - src: data of the circular source 
%   - fp.r, fp.theta, fp.phi: the radial, zenithal, and azimuthal
%       coordinates of the field points
%   - 'max_order': the maximum order for the spherical Bessel functions
%   - Zernike.n, Zernike.m, the radial and azimuthal mode number of 
%       Zernike polynomials
% -------------------------------------------------------------------------
% DIMENSION
%   fp.r -> fp.theta -> fp.phi
% =========================================================================
function [prs, vel] = CircPal_SWE_Addition_new_0406(pal1, pal2, fp, Y_tot, sum_coef, T1, T2, Gaunt_coeff, br, varargin)

    ip = inputParser();
    ip.addParameter('gauss_num', 2e2, @(x)validateattributes(x, {'numeric'}, {'scalar', '>=', 2}));
    ip.addParameter('is_cal_vel', false, @(x)validateattributes(x, {'logical'}, {'scalar'}));
    ip.addParameter('max_order', ceil(pal1.src_ultra.radius*real(pal1.ultra.num)*1.2), ...
        @(x)validateattributes(x, {'numeric'}, {'scalar', '>', 0}));
    ip.parse(varargin{:});
    ip = ip.Results;
    
    pal_radius = pal1.src_ultra.radius;
    
    p0 = 1.21*343*1;

    wn1.ka = real(pal1.audio.num); wn1.k1 = pal1.ultra_high.num;
    wn1.k2 = pal1.ultra_low.num; wn1.ku = pal1.ultra.num;
    wn2.ka = real(pal2.audio.num); wn2.k1 = pal2.ultra_high.num;
    wn2.k2 = pal2.ultra_low.num; wn2.ku = pal2.ultra.num;
    
    Tcoeff.int = T1.int .* conj(permute(T2.int,[3,4,1,2]));
    Tcoeff.ext = T1.ext .* conj(permute(T2.ext,[3,4,1,2]));

    prs = 0 * fp.r .* fp.theta .* fp.phi;

for ir = 1:length(fp.r)

    %% Radial compoment

    if fp.r(ir) < br
        % R_temp dim: nu1 -> 1 -> nu2 -> 1 -> la
        R_temp = CircPal_SWE_Addition_Radial_int_dim(pal_radius, br, sum_coef.la, wn2, fp.r(ir), sum_coef.nu1, sum_coef.nu2);
        R_temp = permute(R_temp, [2,1,3,5,4]);
        
        % T1 dim: nu1 -> mu1
        % T2 dim: 1 -> 1 -> nu2 -> mu2
        % T should be completed: dim1 -> (0:nu) dim2 -> (-nu,nu)
        coeff_rad1 = Tcoeff.int;
        coeff_rad2 = Tcoeff.int;
        coeff_rad3 = Tcoeff.ext;
    else
        R_temp = CircPal_SWE_Addition_Radial_ext_new_0217(pal_radius, br, sum_coef.la, wn2, fp.r(ir), sum_coef.nu1, sum_coef.nu2);
        coeff_rad1 = Tcoeff.int;
        coeff_rad2 = Tcoeff.ext;
        coeff_rad3 = Tcoeff.ext;
    end
    % R dim: nu1 -> mu1 -> nu2 -> mu2 -> la
    R = coeff_rad1 .* R_temp.int + ...
        coeff_rad2 .* R_temp.mid + ... 
        coeff_rad3 .* R_temp.ext;

    for itheta = 1:length(fp.theta)
        for iphi = 1:length(fp.phi)

        %% Spherical harmonics
        % Y dim: 1 -> fp.theta -> fp.phi
        Y = Y_tot(itheta, :, iphi, :, :);

        % Gaunt coeff dim: nu1 -> mu1 -> nu2 -> mu2 -> la
        prs(ir, itheta, iphi) = 16 * pi^2 * 1.2 * p0^2 / (1i*1.21*343^2) * ... 
        sum((-1).^sum_coef.mu2 .* Gaunt_coeff .* R .* Y, 'all');

        end
    end

end

    %% calculate velocity
    % todo
    vel.r = [];
    vel.theta = [];
    vel.phi = [];
    if ~ip.is_cal_vel
        return
    end

    % radial_prime_interior = [];
    % radial_prime_exterior = [];
    % if ~isempty(r_interior)
        % % r, l
        % radial_prime_interior = CircSrcZernikeRadialPrime_Interior_220424B(...
            % k, a, r_interior, max_l, n0, abs(m0), ...
            % 'gauss_num', ip.gauss_num);
        % % r, 1, 1, l
        % radial_prime_interior = permute(radial_prime_interior, [1,4,3,2]);
    % end
    % if ~isempty(r_exterior)
        % % r, l
        % radial_prime_exterior = CircSrcZernikeRadialPrime_Exterior_220424A(...
            % k, a, r_exterior, max_l, n0, abs(m0), ...
            % 'gauss_num', ip.gauss_num);
        % % r, 1, 1, l
        % radial_prime_exterior = permute(radial_prime_exterior, [1,4,3,2]);
    % end
    % radial_prime = [radial_prime_interior; radial_prime_exterior];

    % vel_r = 4*pi/1i .* sum(Y0 .* Y .* radial_prime, 4);

    % Y_prime = 0 * theta.*phi .*ell;
    % if m0 >= 0
        % Y1 = zeros(1, length(theta), length(phi), max_l);
        % for ll = 1:max_l
            % Y1(1,:,:,ll) = SphHarmonic_220419I(2*ll+abs(m0), m0+1, theta, phi);
        % end
        % Y_prime(1,:,:,1) = m0 .* cot(theta) .* Y(1,:,:,1);
        % if m0 == 0
            % Y_prime(1,:,:,1) = 0;
        % end
        % Y_prime(1,:,:,2:end) = m0 .* cot(theta) .* Y(:,:,:,2:end);
        % Y_prime(1,:,:,2:end) = Y_prime(1,:,:,2:end) ...
            % + sqrt((2*ell(2:end)+abs(m0)-m0) .* (2*ell(2:end)+abs(m0)+m0+1)) ...
            % .* exp(-1i * phi) .* Y1;
    % else 
        % Y1 = 0 * theta .* phi .* ell;
        % for ll = ell
            % Y1(1,:,:,ll+1) = SphHarmonic_220419I(2*ll+abs(m0), m0+1, theta, phi);
        % end
        % Y_prime = m0 .* cot(theta) .* Y;
        % Y_prime = Y_prime + sqrt((2*ell+abs(m0)-m0) .* (2*ell+abs(m0)+m0+1)) ...
            % .* exp(-1i * phi) .* Y1;
    % end
    % % Y_prime(1,theta==0,:,:) = 0;
    % if ~isempty(theta(theta==0)) 
        % if (abs(m0) == 1)
            % lll = 2*ell+abs(m0);
            % Y_prime(1,theta==0,:,:) = -m0 .* sqrt((lll .* (lll+1) .* (2*lll+1))/16/pi) + 0*phi;
                % % .* exp(1i*m0*phi);
        % else
            % Y_prime(1,theta==0,:,:) = 0;
        % end
    % end
    % vel_theta = 4*pi/1i .* sum(radial ./ (k.*r) .* Y_prime .* Y0, 4);

    % vel_phi = 1i.*m0.*4*pi/1i .* sum(Y0 .* Y .* radial ./ (k.*r.*sin(theta)), 4);
    % vel_phi(:,theta==0,:,:) = 0;

end
