% =========================================================================
% INTRO
%   - Calculate the radial component for audio sound when calculating
%       the sound pressure generated by a line source in 2D problem
% -------------------------------------------------------------------------
% INPUT
% DIMENSION
%   - 1: r 
%   - 2: 1 (holder for theta)
%   - 3: 1 (holder for phi)
%   - 4: la
%   - 5: l1
%   - 6: l2
% =========================================================================
function R = PalCircSrc_SWE_Radial(pal, r, la_max, l1_max, l2_max, varargin)

    ip = inputParser;
    % number of points for the numerical integration
    ip.addParameter('int_num', 2e3, @(x)validateattributes(x, {'numeric'}, {'scalar', '>=', 2}));
    ip.addParameter('is_farfield', false, @(x)validateattributes(x, {'logical'}, {'scalar'}));
    parse(ip, varargin{:});
    ip = ip.Results;

    a = pal.src_ultra.radius;

    la = permute((0:la_max).', [4,2,3,1]);
    l1 = permute((0:l1_max).', [5,2,3,4,1]);
    l2 = permute((0:l2_max).', [6,2,3,4,5,1]);
    

    % origin points
    idx_origin = r == 0;
    r_origin = r(idx_origin);
    % interior points
    idx_int = (r > 0) & (r < a);
    r_int = r(idx_int);
    % exterior points
    idx_ext = r >= a;
    r_ext = r(idx_ext);

    R = 0 * r .* la .* l1 .* l2;
    if ip.is_farfield
        r_part = [0; 1; 10; 100; 1e3; inf]*a;
        for i = 1:length(r_part)-1
            R = R + PalCircSrc_SWE_RadialJ(...
                pal, la_max, l1_max, l2_max, r_part(i), r_part(i+1), r, ...
                'is_farfield', true, 'int_num', ip.int_num);
        end
    else 
        % process origin points
        if ~isempty(r_origin)
            R(idx_origin, 1, 1, :, :, :) = PalCircSrc_SWE_Int(pal, la, l1_max, l2_max, 0, a, 0, 'h') ...
                + PalCircSrc_SWE_Int(pal, la, l1_max, l2_max, a, a+2, 0, 'h') ...
                + PalCircSrc_SWE_Int(pal, la, l1_max, l2_max, a+2, a+5, 0, 'h') ...
                + PalCircSrc_SWE_Int(pal, la, l1_max, l2_max, a+5, inf, 0, 'h');
        end
        % process interior points
        if ~isempty(r_int)
            % R = PalCircSrc_SWE_Int(pal, la, l1_max, l2_max, 0, a, r, 'j') ...
                % + PalCircSrc_SWE_Int(pal, la, l1_max, l2_max, a, r, r, 'j') ...
                % + PalCircSrc_SWE_Int(pal, la, l1_max, l2_max, r, inf, r, 'h', ...
                % 'int_method', 'direct');
            R(idx_int, 1, 1, :, :, :) = PalCircSrc_SWE_Int(pal, la, l1_max, l2_max, 0, r_int, r_int, 'j') ...
                + PalCircSrc_SWE_Int(pal, la, l1_max, l2_max, r_int, a, r_int, 'h') ...
                + PalCircSrc_SWE_Int(pal, la, l1_max, l2_max, a, a+2, r_int, 'h') ...
                + PalCircSrc_SWE_Int(pal, la, l1_max, l2_max, a+2, a+5, r_int, 'h') ...
                + PalCircSrc_SWE_Int(pal, la, l1_max, l2_max, a+5, inf, r_int, 'h');
        end
        % process exterior points
        if ~isempty(r_ext)
            R(idx_ext, 1, 1, :, :, :) = PalCircSrc_SWE_Int(pal, la, l1_max, l2_max, 0, a, r_ext, 'j') ...
                + PalCircSrc_SWE_Int(pal, la, l1_max, l2_max, a, r_ext, r_ext, 'j') ...
                + PalCircSrc_SWE_Int(pal, la, l1_max, l2_max, r_ext, r_ext+2, r_ext, 'h') ...
                + PalCircSrc_SWE_Int(pal, la, l1_max, l2_max, r_ext+2, r_ext+5, r_ext, 'h') ...
                + PalCircSrc_SWE_Int(pal, la, l1_max, l2_max, r_ext+5, inf, r_ext, 'h');
        end
    end

    %% Coefficient
    m1 = pal.src_low.prf.azimuth_order;
    m2 = pal.src_high.prf.azimuth_order;
    ma = m2 - m1;
	wigner = 0 * l1 .* l2 .* la;
	for i1 = 1:length(l1)
		for i2 = 1:length(l2)
			for ia = 1:length(la)
				wigner(1, 1, 1, ia, i1, i2) = Wigner3j000(...
                    2*l1(i1) + abs(m1), 2*l2(i2) + abs(m2), 2*la(ia) + abs(ma))...
                    .* Wigner3j(...
                    2*l1(i1) + abs(m1), 2*l2(i2) + abs(m2), 2*la(ia) + abs(ma),...
                    -m1, m2, -ma);
			end
		end
	end

    % dim: l1
    Y1 = SphHarmonic(2*l1(:) + abs(m1), m1, pi/2, 0);
    % dim: 1 -> 1 -> 1 -> 1 -> l1
    Y1 = permute(Y1, [5,2,3,4,1]);
    % dim: l2
    Y2 = SphHarmonic(2*l2(:) + abs(m2), m2, pi/2, 0);
    % dim: 1 -> 1 -> 1 -> 1 -> 1 -> l2
    Y2 = permute(Y2, [6,2,3,4,5,1]);
    A = (-1).^m2 .* Y1 .* Y2 .* wigner ...
        .* sqrt((4*l1+2*abs(m1)+1).*(4*l2+2*abs(m2)+1).*(4*la+2*abs(ma)+1)./4/pi);

    R = sum(R .* A, [5, 6]);
end
