% =========================================================================
% INTRO
%   - Calculate the sound pressure generated by a circular radiator using
%       the spherical wave expansion
%   - Modified based on CircSrcZernike_Exp_220420A.m
% -------------------------------------------------------------------------
% INPUT
%   - src: data of the circular source 
%   - fp.r, fp.theta, fp.phi: the radial, zenithal, and azimuthal
%       coordinates of the field points
%   - 'max_order': the maximum order for the spherical Bessel functions
%   - Zernike.n, Zernike.m, the radial and azimuthal mode number of 
%       Zernike polynomials
% -------------------------------------------------------------------------
% DIMENSION
%   fp.r -> fp.theta -> fp.phi -> ell
% =========================================================================
function [prs, vel] = CircSrc_SWE(src, fp, varargin)

    ip = inputParser();
    ip.addParameter('gauss_num', 2e2, @(x)validateattributes(x, {'numeric'}, {'scalar', '>=', 2}));
    ip.addParameter('is_cal_vel', false, @(x)validateattributes(x, {'logical'}, {'scalar'}));
    ip.addParameter('max_order', ceil(src.radius*real(src.wav.num)*1.2), ...
        @(x)validateattributes(x, {'numeric'}, {'scalar', '>', 0}));
    ip.parse(varargin{:});
    ip = ip.Results;

    %% Calculate angular components: spherical harmonics
    % dim: 1, 1, 1, ell
    ell = permute((0:ip.max_order).', [4,2,3,1]); % order
    % dim: ell, 1, 1, 1
    Y0 = SphHarmonic(2*ell(:)+abs(src.prf.azimuth_order), ...
        src.prf.azimuth_order, pi/2, 0);
    % dim: 1, 1, 1, ell
    Y0 = permute(Y0, [4,2,3,1]);
    % dim: ell, 1, theta, phi
    Y = SphHarmonic(2*ell(:)+abs(src.prf.azimuth_order), ...
        src.prf.azimuth_order, permute(fp.theta,[1,3,2]), ...
        permute(fp.phi, [1,2,4,3]));
    % dim: 1, theta, phi, ell
    Y = permute(permute(permute(Y, [1,3,2,4]), [1,2,4,3]), [4,2,3,1]);

    %% Calculate radial components
    R = CircSrc_SWE_Radial(src, fp.r, ip.max_order);

    %% Calculate the sound pressure

    % r_exterior = r(r>=a);
    % r_interior = r(r<a);
    % radial_interior = [];
    % radial_exterior = [];
    % r, n => r, [], [], n
    % if ~isempty(r_interior)
        % radial_interior = permute(...
                % CircSrcZernikeRadial_Interior_220416A(...
                % k, a, r_interior, max_l, n0, abs(m0), ...
                % 'gauss_num', ip.gauss_num), ...
                % [1,4,3,2]);
    % end
    % if ~isempty(r_exterior)
        % radial_exterior = permute(...
            % CircSrcZernikeRadial_Exterior_220413A(...
            % k, a, r_exterior, max_l, n0, abs(m0), ...
            % 'gauss_num', ip.gauss_num), ...
            % [1,4,3,2]);
    % end
    % radial = [radial_interior; radial_exterior];

    p0 = 1.21*343;
    
    prs = 4*pi*p0 * sum(Y0 .* Y .* R, 4);

    %% calculate velocity
    % todo
    vel.r = [];
    vel.theta = [];
    vel.phi = [];
    if ~ip.is_cal_vel
        return
    end

    % radial_prime_interior = [];
    % radial_prime_exterior = [];
    % if ~isempty(r_interior)
        % % r, l
        % radial_prime_interior = CircSrcZernikeRadialPrime_Interior_220424B(...
            % k, a, r_interior, max_l, n0, abs(m0), ...
            % 'gauss_num', ip.gauss_num);
        % % r, 1, 1, l
        % radial_prime_interior = permute(radial_prime_interior, [1,4,3,2]);
    % end
    % if ~isempty(r_exterior)
        % % r, l
        % radial_prime_exterior = CircSrcZernikeRadialPrime_Exterior_220424A(...
            % k, a, r_exterior, max_l, n0, abs(m0), ...
            % 'gauss_num', ip.gauss_num);
        % % r, 1, 1, l
        % radial_prime_exterior = permute(radial_prime_exterior, [1,4,3,2]);
    % end
    % radial_prime = [radial_prime_interior; radial_prime_exterior];

    % vel_r = 4*pi/1i .* sum(Y0 .* Y .* radial_prime, 4);

    % Y_prime = 0 * theta.*phi .*ell;
    % if m0 >= 0
        % Y1 = zeros(1, length(theta), length(phi), max_l);
        % for ll = 1:max_l
            % Y1(1,:,:,ll) = SphHarmonic_220419I(2*ll+abs(m0), m0+1, theta, phi);
        % end
        % Y_prime(1,:,:,1) = m0 .* cot(theta) .* Y(1,:,:,1);
        % if m0 == 0
            % Y_prime(1,:,:,1) = 0;
        % end
        % Y_prime(1,:,:,2:end) = m0 .* cot(theta) .* Y(:,:,:,2:end);
        % Y_prime(1,:,:,2:end) = Y_prime(1,:,:,2:end) ...
            % + sqrt((2*ell(2:end)+abs(m0)-m0) .* (2*ell(2:end)+abs(m0)+m0+1)) ...
            % .* exp(-1i * phi) .* Y1;
    % else 
        % Y1 = 0 * theta .* phi .* ell;
        % for ll = ell
            % Y1(1,:,:,ll+1) = SphHarmonic_220419I(2*ll+abs(m0), m0+1, theta, phi);
        % end
        % Y_prime = m0 .* cot(theta) .* Y;
        % Y_prime = Y_prime + sqrt((2*ell+abs(m0)-m0) .* (2*ell+abs(m0)+m0+1)) ...
            % .* exp(-1i * phi) .* Y1;
    % end
    % % Y_prime(1,theta==0,:,:) = 0;
    % if ~isempty(theta(theta==0)) 
        % if (abs(m0) == 1)
            % lll = 2*ell+abs(m0);
            % Y_prime(1,theta==0,:,:) = -m0 .* sqrt((lll .* (lll+1) .* (2*lll+1))/16/pi) + 0*phi;
                % % .* exp(1i*m0*phi);
        % else
            % Y_prime(1,theta==0,:,:) = 0;
        % end
    % end
    % vel_theta = 4*pi/1i .* sum(radial ./ (k.*r) .* Y_prime .* Y0, 4);

    % vel_phi = 1i.*m0.*4*pi/1i .* sum(Y0 .* Y .* radial ./ (k.*r.*sin(theta)), 4);
    % vel_phi(:,theta==0,:,:) = 0;

end
